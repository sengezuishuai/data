#define _CRT_SECURE_NO_WARNINGS 1
//在编译和链接之前，还需要对源文件进行一些文本方面的操作，比如文本替换、文件包含、删除部分代码等，这个过程叫做预处理，由预处理程序完成。
//
//预处理命令是什么？
//以#号开头的命令称为预处理命令。
//
//在编译之前对源文件进行简单加工的过程，就称为预处理（即预先处理、提前处理）。
//
//预处理主要是处理以#开头的命令，例如#include <stdio.h>等。预处理命令要放在所有函数之外，而且一般都放在源文件的前面。

//#include的用法详解
//#include 的用法有两种，如下所示：
//
//#include <stdHeader.h>
//#include “myHeader.h”
//
//使用尖括号< >和双引号" "的区别在于头文件的搜索路径不同：
//
//使用尖括号< >，编译器会到系统路径下查找头文件；
//而使用双引号" "，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。
//也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。
//
//不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。


//#define的用法 宏定义
//#define叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。
//例：
//#include <stdio.h>
//#define N 100//宏定义，N为宏名，100是宏的内容
//
//int main() {
//    int sum = 20 + N;
//    printf("%d\n", sum);//运行结果为120
//    return 0;
//}


//宏定义的一般形式为：
//
//#define 宏名 字符串
//
//#表示这是一条预处理命令，所有的预处理命令都以# 开头。
//
//宏名是标识符的一种，命名规则和变量相同。(可由字母、数字、下划线构成，只能以字母、下划线开头)
//
//字符串可以是数字、表达式、if 语句、函数等。
//
//对 #define 用法的几点说明
//宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。
//
//宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。
//
//宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。例如:


//#define PI 3.14159
//
//int main() {
//    Code;
//    return 0;
//}
//
//#undef PI
//
//void func() 
//{
//    Code;
//}
//表示 PI 只在 main() 函数中有效，在 func() 中无效。
//4.代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替，例如：
//#include <stdio.h>
//#define OK 100
//int main() 
//{
//    printf("OK\n");//运行结果：OK
//    printf("%d", OK);
//    return 0;
//}
 

//该例中定义宏名 OK 表示 100，但在 printf 语句中 OK 被引号括起来，因此不作宏替换，而作为字符串处理。
//5.宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。例如：
//#define PI 3.1415926
//#define S PI*y*y    /* PI是已定义的宏名*/
//printf("%f", S);
//在宏替换后变为：
//
//printf("%f", 3.1415926 * y * y);
//
///*习惯上宏名用大写字母*/表示，以便于与变量区别。但也允许用小写字母。
//
//可用宏定义表示数据类型，使书写方便。例如：

//#define UINT unsigned int
////在程序中可用 UINT 作变量说明：
//UINT a, b;
//

//应注意用宏定义表示数据类型和用typedef定义数据说明符的区别:
//宏定义只是简单的字符串替换，由预处理器来处理；
//而 typedef是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。
//例：

//#define PIN1 int *
//typedef int* PIN2;  //也可以写作typedef int (*PIN2);
//PIN1 a, b;
//PIN2 a, b;

//在用宏PIN1代换后变成：int* a, b; 表示a是指向int整型的指针变量，而b只是整型变量
//而用typedef定义的的PIN2代换后变为：int* a, * b; 表示 a、b 都是指向整型的指针变量。
//
//带参数的宏定义
//C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。
//
//对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。
//
//带参宏定义的一般形式为：
//
//#define 宏名(形参列表) (字符串)
////在字符串中可以含有各个形参
////为避免歧义，字符串要用括号括起来，后面的例子会具体说
//
//带参宏调用的一般形式为：
//
//宏名(实参列表);
//
//例：

//#include <stdio.h>
//#define MAX(a,b) (a>b) ? a : b
////用宏名MAX表示条件表达式(a>b) ? a : b，形参 a、b 均出现在条件表达式中
//int main() {
//    int x, y, max;
//    printf("input two numbers: ");
//    scanf("%d %d", &x, &y);
//    max = MAX(x, y);
//    //宏调用，实参 x、y 将用来代替形参 a、b。宏展开后该语句为：max=(x>y) ? x : y;
//    printf("max=%d\n", max);
//    return 0;
//}

//运行结果：
//
//input two numbers : 10 20
//max = 20
//
//对带参宏定义的说明
//1.带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。
//例：
//把
//#define MAX(a,b) (a>b)?a:b 
//写为：
//#define MAX  (a,b)  (a>b)?a:b// MAX和(a,b)中间有空格

//将被认为是无参宏定义，宏名 MAX 代表字符串(a, b) (a > b) ? a : b
//
//宏展开时，宏调用语句：max = MAX(x, y);
//将变为：max = (a, b)(a > b) ? a : b(x, y);
//这显然是错误的
//
//在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。
//这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。
//
//【示例】输入 n，输出(n + 1) ^ 2 的值。


//#include <stdio.h>
//#define SQ(y) (y)*(y)
//int main() {
//    int a, sq;
//    printf("input a number: ");
//    scanf("%d", &a);
//    sq = SQ(a + 1);
//    printf("sq=%d\n", sq);
//    return 0;
//}

//运行结果：
//
//input a number : 9
//sq = 100
//
//第 2 行为宏定义，形参为 y
//第 7 行宏调用中实参为 a + 1，是一个表达式，在宏展开时，用 a + 1 代换 y，再用(y) * (y)代换 SQ，得到如下语句：
//
//sq = (a + 1) * (a + 1);
//
//这与函数的调用是不同的，函数调用时要把实参表达式的值求出来再传递给形参，而宏展开中对实参表达式不作计算，直接按照原样替换。
//
//在宏定义中，字符串内的形参通常要用括号括起来以避免出错。例如上面的宏定义中(y)* (y)表达式的 y 都用括号括起来，因此结果是正确的。如果去掉括号运行结果为：
//input a number : 9
//sq = 19
//
//同样输入 9，但结果却是不一样的。问题在哪里呢？
//这是由于宏展开只是简单的符号替换的过程，没有任何其它的处理。宏替换后将得到以下语句：
//
//sq = a + 1 * a + 1;
////由于 a 为 9，故 sq 的值为 9+1*9+1=19。
//
//这显然与题意相违，因此参数两边的括号是不能少的。
//
//然而即使在参数两边加括号也还是不够的，例如：


//#include <stdio.h>
//#define SQ(y) (y)*(y)
//int main() {
//    int a, sq;
//    printf("input a number: ");
//    scanf("%d", &a);
//    sq = 200 / SQ(a + 1);
//    printf("sq=%d\n", sq);
//    return 0;
//}

//注意宏调用语句为：sq = 200 / SQ(a + 1);
//运行程序后，如果仍然输入 9，那么我们希望的结果为 2。但实际情况并非如此：
//
//input a number : 9
//sq = 200
//
//为什么会得这样的结果呢？
//
//分析宏调用语句，在宏展开之后变为：
//sq = 200 / (a + 1) * (a + 1);
//a 为 9 时，由于“ / ”和“ * ”运算符优先级和结合性相同，所以先计算 200 / (9 + 1)，结果为 20，再计算 20 * (9 + 1)，最后得到 200。
//
//为了得到正确答案，应该在宏定义中的整个字符串外加括号：


//#include <stdio.h>
//#define SQ(y) ((y)*(y))
//int main() {
//    int a, sq;
//    printf("input a number: ");
//    scanf("%d", &a);
//    sq = 200 / SQ(a + 1);
//    printf("sq=%d\n", sq);
//    return 0;
//}

//由此可见，对于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号。
//
//带参宏定义和函数的区别
//带参数的宏和函数很相似，但有本质上的区别：
//宏展开仅仅是字符串的替换，不会对表达式进行计算； 宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。
//而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。
//
//例：计算平方值
//
//函数
//#include <stdio.h>
//int SQ(int y) {
//    return ((y) * (y));
//}
//int main() {
//    int i = 1;
//    while (i <= 5) {
//        printf("%d^2 = %d\n", (i - 1), SQ(i++));
//    }
//    return 0;
//}
//1 ^ 2 = 1
//2 ^ 2 = 4
//3 ^ 2 = 9
//4 ^ 2 = 16
//5 ^ 2 = 25
//宏
//#include <stdio.h>
//#define SQ(y) ((y)*(y))
//int main() {
//    int i = 1;
//    while (i <= 5) {
//        printf("%d^2 = %d\n", i, SQ(i++));
//    }
//    return 0;
//}

//运行结果：
//
//3 ^ 2 = 2 //1* 2
//5 ^ 2 = 12 //3* 4
//7 ^ 2 = 30 //5* 6
//
//在使用函数的例子中，先把实参 i 传递给形参 y，然后再自增 1，这样每循环一次 i 的值增加 1，所以最终要循环 5 次。
//
//在使用宏的例子中，宏调用只是简单的字符串替换，SQ(i++) 会被替换为((i++) * (i++))，这样每循环一次 i 的值增加 2，所以最终只循环 3 次
//
//带参数的宏也可以用来定义多个语句，在宏调用时，把这些语句又替换到源程序中


//#include <stdio.h>
//#define SSSV(s1, s2, s3, v) s1 = length * width; s2 = length * height; s3 = width * height; v = width * length * height;
//int main() {
//    int length = 3, width = 4, height = 5, sa, sb, sc, vv;
//    SSSV(sa, sb, sc, vv);
//    printf("sa=%d, sb=%d, sc=%d, vv=%d\n", sa, sb, sc, vv);
//    return 0;
//}

//运行结果：
//
//sa = 12, sb = 15, sc = 20, vv = 60
//
//#if、#ifdef、#ifndef条件编译
//引例：假如现在要开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行，怎么办呢？
//
//这个程序的难点在于，不同平台下控制文字颜色的代码不一样，我们必须要能够识别出不同的平台。
//
//Windows 有专有的宏_WIN32，Linux 有专有的宏__linux__


//#include <stdio.h>
//int main() {
//#if _WIN32
//    system("color 0c");
//    printf("http://c.biancheng.net\n");
//#elif __linux__
//    printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
//#else
//    printf("http://c.biancheng.net\n");
//#endif
//    return 0;
//}

//#if、#elif、#else 和 #endif 都是预处理命令，整段代码的意思是：如果宏_WIN32的值为真，就保留第 4、5 行代码，删除第 7、9 行代码；如果宏 __linux__ 的值为真，就保留第 7 行代码；如果所有的宏都为假，就保留第 9 行代码。
//
//这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。
//
//这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。 条件编译是预处理程序的功能，不是编译器的功能。
//
//#if 的用法
//#if 整型常量表达式1
//程序段1
//#elif 整型常量表达式2
//程序段2
//#elif 整型常量表达式3
//程序段3
//#else
//程序段4
//#endif
//
//它的意思是：如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。
//
//需要注意的是，#if 命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。
//
//#ifdef 的用法
//#ifdef 用法的一般格式为：
//#ifdef 宏名
//程序段1
//#else
//程序段2
//#endif
//
//它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。
//
//#ifdef可以认为是 #if defined的缩写。
//
//也可以省略 #else：
//
//#ifdef 宏名
//程序段
//#endif
//
//例：

//#include <stdio.h>
//#include <stdlib.h>
//int main() {
//#ifdef _DEBUG
//    printf("正在使用 Debug 模式编译程序...\n");
//#else
//    printf("正在使用 Release 模式编译程序...\n");
//#endif
//    system("pause");
//    return 0;
//}

//当以 Debug 模式编译程序时，宏 _DEBUG会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。
//
//#ifndef 的用法
//#ifndef 宏名
//程序段1
//#else
//程序段2
//#endif
//
//它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与#ifdef的功能正好相反。
//
//三者之间的区别
//最后需要注意的是，#if后面跟的是“整型常量表达式”，而 #ifdef和 #ifndef后面跟的只能是一个宏名，不能是其他的。
//例如，下面的形式只能用于 #if：


//#include <stdio.h>
//#define NUM 10
//int main() {
//#if NUM == 10 || NUM == 20
//    printf("NUM: %d\n", NUM);
//#else
//    printf("NUM Error\n");
//#endif
//    return 0;
//}

//运行结果：
//
//NUM : 10
//
//再如，两个宏都存在时编译代码A，否则编译代码B：

//#include <stdio.h>
//#define NUM1 10
//#define NUM2 20
//int main() {
//#if (defined NUM1 && defined NUM2)
//    //代码A
//    printf("NUM1: %d, NUM2: %d\n", NUM1, NUM2);
//#else
//    //代码B
//    printf("Error\n");
//#endif
//    return 0;
//}

//运行结果：
//
//NUM1 : 10, NUM2 : 20
//
//以下代码也能获得同样的运行结果：

//#include <stdio.h>
//#define NUM1 10
//#define NUM2 20
//int main() {
//#ifdef NUM1
//    printf("NUM1:%d,", NUM1);
//#else
//    printf("error");
//#endif
//
//#ifdef NUM2
//    printf("NUM2:%d", NUM2);
//#else
//    printf("error");
//#endif
//    return 0;
//}

//预处理命令总结
//预处理指令是以#号开头的代码行，# 号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和 # 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。
//
//指令	说明
//#	空指令，无任何效果
//#include	包含一个源代码文件
//#define	定义宏
//#undef	取消已定义的宏
//#if	如果给定条件为真，则编译下面代码
//#ifdef	如果宏已经定义，则编译下面代码
//#ifndef	如果宏没有定义，则编译下面代码
//#else	如果前面的#if给定条件不为真，当前条件为真，则编译下面代码
//#endif	结束一个#if……#else条件编译块
//预处理功能是C语言特有的功能，它是在对源程序正式编译前由预处理程序完成的，程序员在程序中用预处理命令来调用这些功能。
//
//宏定义可以带有参数，宏调用时是以实参代换形参，而不是“值传送”。
//
//为了避免宏代换时发生错误，宏定义中的字符串应加括号，字符串中出现的形式参数两边也应加括号。
//
//文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。
//
//条件编译允许只编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。
//
//使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计。






